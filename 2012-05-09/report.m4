include(`../lib.m4')dnl
header(`1', `408', `プロセス、リダイレクション、パイプ')dnl

今回用いたプログラムのソースコードを以下に示す。

source(`408.c')dnl

このプログラムは、コマンドライン引数の1番目に出力のサイズを取り、2番目に子プロセ
スの数を取る。

fork_interactive() 関数は、fork と同時に双方向のパイプを作成する関数である。親の
場合であっても子の場合であっても、pipe_fd 配列の0番目に親から子へのパイプのファ
イルディスクリプタが代入され、1番目に子から親へのパイプのファイルディスクリプタ
が代入される。戻り値は fork 関数のそれと同じである。

writeb() 関数は、指定したファイルディスクリプタ fd に指定した1バイトの(char 型の
)データ c を書き込む関数である。戻り値は write 関数のそれと同じである。

main() 関数では、まず fork_interactive() 関数を用いて指定された数の子プロセスを
作っている。これが終わった時点で、全てのプロセスが双方向のパイプによって数珠繋ぎ
のようになっている。
親プロセスでは指定された回数だけ標準出力への出力と最初の子プロセスへの指示を交互
に行う。子プロセスへの指示にはパイプを用い、出力するべき1バイトの情報を送る。全
ての子プロセスは出力を終えたら必ず1バイトの情報を1つ上の親プロセスに送るものとし
、親プロセスではこれを待ってから次の標準出力への出力を実行する。
子プロセスでは、そのプロセスと下にいる全ての子プロセスを p とし、受信した情報の
番号(最初を0とし、1ずつ増やしていく)を n としたときに、n が p の倍数であるときだ
けその場で文字を出力し、それ以外は全て子プロセスにそのまま渡せば良い。親プロセス
から渡された情報の番号をカウントし、n が p の倍数である場合は、親プロセスから渡
された文字を標準出力に書き出して親プロセスに出力した文字を返す。そうでない場合は
親プロセスから渡された文字をそのまま子プロセスに渡し、子プロセスから渡された文字
をそのまま親プロセスに渡す。また、次の子プロセスが無い場合は p = 1 となるため、n
は必ず p の倍数となる。よって、その場合を考慮して分岐を増やす必要は無い。

このプログラムが正しく振る舞うことを示すため、以下に網羅的な実行例を示す。

syscmd(`
for onum in $(seq 0 64) ; do
    for pnum in $(seq 1 16) ; do
        echo "\$ ./408 $onum $pnum"
        ./408 $onum $pnum
    done
done
')dnl

以上のように、どの場合においても期待した振舞いをしている。また、./408 131072 16
を実行した状態で pstree コマンドを実行すると、
     ├─tmux─┬─sh───zsh
     │      ├─sh───zsh───vim
     │      ├─sh───zsh───408───408───408───408───408───408───408───408───408───408───408───408───408───408───408───408───408
     │      └─sh───zsh───pstree
このように子プロセスが連なっていることが分かる。

footer()dnl
